---
topic: 스레드와 핸들러
description: 스레드에 대한 정리
author: 김민석
---

# Thread란?

OS 플랫폼에 따라 경량 프로세스(light weight process)라고 불리기도 하며,
네이버 지식백과에서는 스레드를 아래와 같이 정의하고 있다.

> 컴퓨터 프로그램 수행 시 프로세스 내부에 존재하는 수행 경로, 즉 일련의 실행코드이다. 프로세스는 단순한 껍데기일 뿐, 실제 작업은 스레드가 담당한다. 프로세스 생성 시 하나의 주 스레드(메인스레드)가 생성되어 대부분의 작업을 처리하고 주 스레드가 종료되면 프로세스도 종료된다. 하나의 운영 체계에서 여러 개의 프로세스가 동시에 실행되는 환경이 멀티 태스킹이고, 하나의 프로세스 내에서 다수의 프로세스가 동시에 수행되는것이 멀티 쓰레딩이다.

- 보통 하나의 프로그램(application)의 프로세스 안에서 동작
- OS 역할을 JVM이 해주기 때문에 자바에는 프로세스가 없으며, 스레드만 존재
- 자바의 스레드는 JVM에 의해 스케줄링되는 실행 단위 코드 블록
- 당연히 스레드와 관련된 정보는 JVM이 관리함
  - 스레드가 몇 개 존재하는가
  - 스레드가 어떤 상태인가
  - 우선순위가 얼마인가

# Multi Thread

- 스레드는 하나의 프로세스안에서 각 스레드마다 stack을 가지지만 프로세스의 code, data, heap 영역은 공유한다.
  - 즉 하나의 프로레스의 스레드마다 갖는 Stack 외에는 모든 메모리 자원을 공유한다는 의미
  - ![preview](preview/thread.png)

# Multi Thread와 비동기의 차이

얼핏보면 개념이 비슷해 보이는 비동기와 멀티스레드는 확실한 구분이 필요하다.

- 멀티 스레드
  - 요청 개수당 1개의 Thread가 생성되며 이는 cpu의 코어수에 따라 개수가 제한된다.
  - 멀티스레드에도 비동기와 동기가 존재한다. 
    - 이는 안드로이드에서는 callback(non-blocking) 인지 return(blocking) 인지로 알 수 있다.

- 비동기
  - 멀티 스레드와는 다르게 요청이 아무리 많아도 스레드는 일정 개수 이상 생기지 않는다.
    - "최소 자원으로 얼마나 더 많은 요청을 처리할 수 있는가"를 목적으로 Worker Thread를 할당받는다.
  - I/O 작업에서는 요청 사항이 많으면 많을 수록 Multi Thread에 비해 성능이 월등하다.


# Java의 스레드 관련 메소드

코틀린의 네이티브 스레드는 코루틴이지만,
역시 자바의 스레드도 사용가능하다.

| 메소드 | 설명 |
| ------ |:---------:|
| interrupt() | 일시정지 중인 스레드를 IterruptedException를 발생시키며, try-catch로 초기상태로 돌아가거나 종료 상태로 갈 수 있도록 한다. |
| notify(), notifyAll() | wait() 메소드에 의해 일시중지 상태에 있는 스레드를 대기상태로 만듬 |
| sleep(long), sleep(long millis, int nanos) | 주어진 시간동안 스레드를 일시정지 상태로 만들고, 주어진 시간이 지나면 실행대기 상태로 바뀐다. |
| join(), join(long millis), join(long millis, int nanos) | join() 메소드를 호출한 스레드는 sleep() 과 비슷하게 일시정지 상태를 갖지만, 차이점은 매개변수가 없다면 join() 메소드를 실행한 스레드가 종료되어야 일시정지 상태에서 벗어난다. |
| wait(), wait(long millis), wait(long millis, int nanos) | join() 과 비슷하지만 notify(), notifyAll()를 사용하여 일지정지 상태에서 벗어난다. |
| yield() | 실행 중 우선순위가 동일한 다른 스레드에게 실행을 양보하고 실행 대기 상태가 된다. |

# 결론

안드로이드 개발을 하면서 코틀린을 쓰고 있다면
그냥 rx, 코루틴쓰자..